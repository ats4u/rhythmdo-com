#!/usr/bin/env python3
"""
Build a Markdown TOC from multiple sidebar YAMLs (order from _sidebar.conf).

Rules:
- Merge ONLY the root `website.sidebar.contents` arrays, in the order they appear
  in _sidebar.conf. No section merging at any depth; same-titled sections are
  kept as separate branches.
- Follow nested subsections exactly as in YAML.
- Paths use the "directory" convention: `article/ja/` (no filename). We read
  titles from `<dir>/index.qmd` and link to `/article/ja/`.
- If a `.qmd` path appears, we still link to `/path/` (directory style) but read
  the title from that `.qmd`.
- Output is nested Markdown lists.

Usage:
  python bin/build_toc_md.py _sidebar.conf > _toc.md

Include in Quarto:
  {{< include _toc.md >}}
"""
from __future__ import annotations
import sys
import re
from pathlib import Path
from typing import Any, Dict, List, Union

try:
    import yaml  # pip install pyyaml
except ModuleNotFoundError:
    sys.exit("Please: pip install pyyaml")

# Project root (assuming this script lives at ./bin/build_toc_md.py)
ROOT = Path(__file__).resolve().parents[1]

# Front matter / H1 extractors
FM_RE = re.compile(r'^\ufeff?---\s*\n(.*?)\n(?:---|\.\.\.)\s*(?:\n|$)', re.DOTALL | re.MULTILINE)
H1_RE = re.compile(r'^\s*#\s+(.+?)\s*$', re.MULTILINE)


def load_yaml(p: Path) -> Dict[str, Any]:
    with p.open('r', encoding='utf-8') as f:
        return yaml.safe_load(f) or {}


def read_conf_list(conf_path: Path) -> List[Path]:
    """
    Read filenames from _sidebar.conf (one per line), relative to project root.
    Ignores blank lines and lines starting with '#'.
    """
    out: List[Path] = []
    for line in conf_path.read_text(encoding='utf-8').splitlines():
        s = line.strip()
        if not s or s.startswith("#"):
            continue
        out.append((ROOT / s).resolve())
    return out


def resolve_target(rel: str) -> tuple[str, Path]:
    """
    Return (href-as-directory, qmd_path).

    - If `rel` ends with '/', treat as directory: href '/rel/', qmd '<rel>/index.qmd'.
    - If `rel` ends with '.qmd': href '/rel-without-ext/', qmd '<rel>'.
    - Else: treat as directory path.
    """
    rel = rel.strip()
    if rel.endswith("/"):
        href = "/" + rel
        qmd_rel = rel + "index.qmd"
    elif rel.endswith(".qmd"):
        href = "/" + rel[:-4] + "/"
        qmd_rel = rel
    else:
        href = "/" + rel.rstrip("/") + "/"
        qmd_rel = rel.rstrip("/") + "/index.qmd"
    return href, (ROOT / qmd_rel).resolve()


def pick_title_from_qmd(qmd_path: Path) -> str:
    """
    Title priority:
      1) front matter 'title'
      2) first '# H1' line
      3) filename stem
    """
    try:
        txt = qmd_path.read_text(encoding='utf-8', errors='ignore')
    except FileNotFoundError:
        return qmd_path.stem

    m = FM_RE.match(txt)
    if m:
        try:
            data = yaml.safe_load(m.group(1)) or {}
            t = data.get("title")
            if isinstance(t, (str, int, float)):
                return str(t).strip()
        except Exception:
            pass
    m = H1_RE.search(txt)
    if m:
        return m.group(1).strip()
    return qmd_path.stem


Node = Union[str, Dict[str, Any]]  # str = item path; dict = {section, contents}


def render_md(node: Node, depth: int, out_lines: List[str]) -> None:
    """
    Recursively render a node to Markdown.
    - Section: "- Title" then children indented.
    - Item string: "- [Title](/dir/)".
    """
    indent = "  " * depth

    # Leaf item: string path
    if isinstance(node, str):
        href, qmd_path = resolve_target(node)
        title = pick_title_from_qmd(qmd_path) if qmd_path.exists() else Path(node.rstrip("/")).name or "untitled"
        out_lines.append(f"{indent}- [{title}]({href})")
        return

    # Section object
    if isinstance(node, dict) and "section" in node and "contents" in node:
        section_title = str(node.get("section", "")).strip()
        out_lines.append(f"{indent}- {section_title}")
        for child in node.get("contents") or []:
            render_md(child, depth + 1, out_lines)
        return

    # Fallback: unknown dict â†’ try to find a string path value
    if isinstance(node, dict):
        for v in node.values():
            if isinstance(v, str):
                render_md(v, depth, out_lines)
                return
    # Else: ignore silently


def main() -> None:
    if len(sys.argv) < 2:
        print("Usage: build_toc_md.py _sidebar.conf > _toc.md", file=sys.stderr)
        sys.exit(2)

    conf = Path(sys.argv[1]).resolve()
    if not conf.exists():
        sys.exit(f"Config not found: {conf}")

    ymls = read_conf_list(conf)

    # Merge ONLY the root website.sidebar.contents arrays, in listed order.
    root_items: List[Node] = []
    for yml in ymls:
        if not yml.exists():
            print(f"[warn] YAML not found: {yml}", file=sys.stderr)
            continue
        data = load_yaml(yml)
        node = (((data.get("website") or {}).get("sidebar") or {}).get("contents"))
        if isinstance(node, list):
            root_items.extend(node)

    lines: List[str] = []
    for item in root_items:
        render_md(item, 0, lines)

    sys.stdout.write("\n".join(lines) + "\n")


if __name__ == "__main__":
    main()

