---
title: 多次元グルーヴ空間理論
created: 2025-05-27T11:07
format: html
execute:
  enabled: true
  echo: false
  output: true
  eval: true
  cache: false
title-block: false
tags:
  - foo
---

リズムを明確かつ精密に認識するための基礎的な技術──それが「グルーヴ空間理論」です。この理論は、オフビートカウント理論を土台として作られたもので、様々なジャンルの音楽のグルーヴを解析できる様に拡張されたものです。世界中のリズムが持っている **分裂拍(Schizorythymos)** の本質を様々な方法を使って把握する為に汎用可能な理論を提供します。

## 多次元グルーヴ空間理論とは

グルーヴ空間理論とは、拍の数え方を拡張する為の理論です。 これまで  **ディヴィジョン（拍 =４分音符）** と **サブディヴィジョン（分拍＝連符）**  に対して数を数える方法を御説明致しました。このディヴィジョンを**多次元化** を使って４つの **グルーヴ空間**に拡張することにより、幅広いグルーヴの理解を行うことができる様にする理論がグルーヴ空間理論です。

グルーヴ空間理論では、ディヴィジョン・サブディヴィジョンを1つの **グルーヴ空間**として扱います。

そしてこのグルーヴ空間を**多次元化**を使って拡張し**マクロディヴィジョン(小節)** と **マイクロディヴィジョン(ずれニュアンス)** という２つの新しい **グルーヴ空間**を定義します。

一般的にグルーヴと言われているリズムは、小節自体も拍とみなし小節にも弱拍先行を適用することによって説明出来るという **マクロディヴィジョン・グルーヴ空間** という概念を御紹介致します。

次に、一般的にレイドバック・ラッシュ・ドラッグ等々と呼ばれている音符のずれによるニュアンスの表現は、譜面上に表される **サブディヴィジョン(分拍)** よりも更に細かい音符 **マイクロディヴィジョン(微分拍)**空間 が存在すると仮定し、これらに弱拍先行を適用することで合理的に説明できる ─── という理論を御紹介致します。

音符のずれによるニュアンスの表現は、**ディヴィジョン（拍）**  を **マクロディヴィジョン（小節＝合拍）** とみなし **サブディヴィジョン（連符＝分拍）**をディヴィジョンとみなした時のサブディヴィジョンによる弱拍先行リズムとして表現が可能になる ─── **グルーヴ空間転送** という理論を御説明致します。

これらの理論を使うことで、グルーヴ習得の為の具体的な練習方法を考案したり、DAW上で機械的にグルーヴを再現することが出来るようになります。

<!--
<div class="ats4u-twitter-video">https://x.com/ats4u/status/1754113170548175104</div>
<div class="ats4u-twitter-video" >https://x.com/ats4u/status/1741136150394458596</div>
-->
   

## ４つのグルーヴ空間
これまでオフビートカウントで拍を数えるにあたって、４分音符１つを１拍とする単位（ディヴィジョン）で数えて来ました。

そして４分音符を分割して出来る８分音符や３連符などの拍（サブ・ディヴィジョン）については、数字ではなく **＆** **Ｅ** **Ａ** の３つの 記号/アルファベット を割り当てることで数えてきました。

このディヴィジョン・サブディヴィジョンのことをここでは**グルーヴ空間** と呼びます。 通常のリズム理論ではこのグルーヴ空間は、**ディヴィジョン** と **サブディヴィジョン** の２つが存在します。

グルーヴ空間理論では、この２つのグルーヴ空間を**多次元化**という処理を加えることにおって拡張し４つのグルーヴ空間を定義します。

* ４つのグルーヴ空間
  * マクロ・ディヴィジョン(小節=合拍=Macrodivision)
  * ディヴィジョン (4分音符=拍=Division )
  * サブ・ディヴィジョン (８分音符等々の分音符=分拍=Subdivision )
  * マイクロ・ディヴィジョン(音符では書き表せない拍＝微分拍=Microdivision)

そしてこの４つのグルーヴ空間の特徴を説明致します。

```{python}
#| output: asis
from pathlib import Path
import sys

# Go one directory up from the current working dir
parent = Path.cwd().parent.parent

if str(parent) not in sys.path:
    sys.path.insert(0, str(parent))

# now imports from project root work

from lib.groovespace import *


```

### ディヴィジョンとは

これまで拍を数えるときは**１２３４、１２３４**と小節を繰り返しながら、その各小節内の拍数を数えて来ました。 この小節を分割して出来る数を **ディヴィジョン** と呼びます。

次の表は、ディヴィジョンの例です。

```{python}
#| output: asis
print(
    show_beat(
        [
            [ 1, 2, 3, 4 ] *4
        ],
        [
            [B1, N, N, N ] *4
        ]
    )
)
```

### 多次元化とは

多次元化とは、次の様に数を数えるときの**桁数** を増やすことをいいます。前章の例で挙げた様にディヴィジョン（拍数）を数える際、次の様に小節数を同時に数えると次のようになります。

```{python}
#| output: asis
print(
    show_beat(
        [
            [ 1, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ]
        ],
        [
            [R1, N, N, N ] *4
        ]
    )
)
```

この様に拍数を一定の周期で数える時に、その周期の先頭拍で周期が来た回数（小節数）を数えることを **多次元化**と呼びます。又は、これまでのオフビートカウントが発展してきた歴史的経緯から **小節数入りカウント**  呼ばれることもあります。

### マクロディヴィジョンとは

マクロディヴィジョンについて説明します。

#### ディヴィジョンを多次元化する

ここでディヴィジョン自体を多次元化すること考えてみます。次の図は前章で見た図と全く同じディヴィジョンの図です。

```{python}
#| output: asis
print(
    show_beat(
        [
            [ 1, 2, 3, 4 ] *4
        ],
        [
            [B1, N, N, N ] *4
        ]
    )
)
```

このディヴィジョンを多次元化すると次の図になります。これも前章で見た図と全く同じ図です。

```{python}
#| output: asis
print(
    show_beat(
        [
            [ 1, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ]
        ],
        [
            [R1, N, N, N ] *4
        ]
    )
)
```

このように多次元化されたディヴィジョンのことを **マクロディヴィジョン (Macrodivision)** と呼びます。

#### マクロディヴィジョンを多次元化する

このように、小節数入りで数えている時、ある数の小節のまとまりに対して更にもうひとつ次元を増やして数えると次の様になります。

```{python}
#| output: asis
print(
    show_beat(
        [
            [ 1, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 2, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 3, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 4, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
        ],
        [
            [R1, N, N, N ] + [ B1, N, N, N ] * 3,
            [R2, N, N, N ] + [ B1, N, N, N ] * 3,
            [R3, N, N, N ] + [ B1, N, N, N ] * 3,
            [R4, N, N, N ] + [ B1, N, N, N ] * 3,
        ]
    )
)
```

このように数えることを**マクロディヴィジョンの多次元化** と呼びます。また多次元化されたマクロディヴィジョンを **二次元マクロディヴィジョン(Double-Layered Macrodivision)** と呼びます。

#### 多次元化したマクロディヴィジョンをもう一度多次元化する

既に多次元化したマクロディヴィジョンを更に多次元化することも可能です。 次の様に更にもう一次元増やすことで**三次元マクロディヴィジョン(Triple-Layered Macrodivision)** を構築できます。

```{python}
#| output: asis
print(
    show_beat(
        [
            [ 1, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 2, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 3, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 4, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 2, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 2, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 3, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 4, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 3, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 2, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 3, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 4, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 4, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 2, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 3, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 4, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
        ],
        [
            [G1, N, N, N ] + [ B1, N, N, N ] * 3,
            [R2, N, N, N ] + [ B1, N, N, N ] * 3,
            [R3, N, N, N ] + [ B1, N, N, N ] * 3,
            [R4, N, N, N ] + [ B1, N, N, N ] * 3,
            [G2, N, N, N ] + [ B1, N, N, N ] * 3,
            [R2, N, N, N ] + [ B1, N, N, N ] * 3,
            [R3, N, N, N ] + [ B1, N, N, N ] * 3,
            [R4, N, N, N ] + [ B1, N, N, N ] * 3,
            [G3, N, N, N ] + [ B1, N, N, N ] * 3,
            [R2, N, N, N ] + [ B1, N, N, N ] * 3,
            [R3, N, N, N ] + [ B1, N, N, N ] * 3,
            [R4, N, N, N ] + [ B1, N, N, N ] * 3,
            [G4, N, N, N ] + [ B1, N, N, N ] * 3,
            [R2, N, N, N ] + [ B1, N, N, N ] * 3,
            [R3, N, N, N ] + [ B1, N, N, N ] * 3,
            [R4, N, N, N ] + [ B1, N, N, N ] * 3,
        ],
        [
            N,
            N,
            N,
            N,
            ROW1,
            N,
            N,
            N,
            ROW1,
            N,
            N,
            N,
            ROW1,
            N,
            N,
            N,
        ]
    )
)
```

#### 多次元化したマクロディヴィジョンの呼び方

多次元化したマクロディヴィジョンの次元の呼び方を説明します。 

##### 一次元マクロディヴィジョン＝第一次元
次の様に数えることを**一次元マクロディヴィジョン(One-Dimensional Macrodivision)**と呼びます。

```{python}
#| output: asis
print(
    show_beat(
        [
            [ 1, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 1, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 1, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 1, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
        ],
        [
            [B1, N, N, N ] + [ B1, N, N, N ] * 3,
            [B1, N, N, N ] + [ B1, N, N, N ] * 3,
            [B1, N, N, N ] + [ B1, N, N, N ] * 3,
            [B1, N, N, N ] + [ B1, N, N, N ] * 3,
        ]
    )
)
```
そしてここでは、この次元を **第一次元** と呼びます。

##### 二次元マクロディヴィジョン＝第二次元
次の様に数えることを**二次元マクロディヴィジョン(Two-Dimensional Macrodivision)** と呼びます。

```{python}
#| output: asis
print(
    show_beat(
        [
            [ 1, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 2, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 3, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 4, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
        ],
        [
            [R1, N, N, N ] + [ B1, N, N, N ] * 3,
            [R2, N, N, N ] + [ B1, N, N, N ] * 3,
            [R3, N, N, N ] + [ B1, N, N, N ] * 3,
            [R4, N, N, N ] + [ B1, N, N, N ] * 3,
        ]
    )
)
```
そしてここでは、この次元を **第二次元** と呼びます。

##### 三次元マクロディヴィジョン＝第三次元
次の様に数えることを**三次元マクロディヴィジョン(Three-Dimensional Macrodivision)** と呼びます。

```{python}
#| output: asis
print(
    show_beat(
        [
            [ 1, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 2, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 3, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 4, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 2, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 2, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 3, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 4, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 3, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 2, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 3, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 4, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 4, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 2, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 3, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 4, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
        ],
        [
            [G1, N, N, N ] + [ B1, N, N, N ] * 3,
            [R2, N, N, N ] + [ B1, N, N, N ] * 3,
            [R3, N, N, N ] + [ B1, N, N, N ] * 3,
            [R4, N, N, N ] + [ B1, N, N, N ] * 3,
            [G2, N, N, N ] + [ B1, N, N, N ] * 3,
            [R2, N, N, N ] + [ B1, N, N, N ] * 3,
            [R3, N, N, N ] + [ B1, N, N, N ] * 3,
            [R4, N, N, N ] + [ B1, N, N, N ] * 3,
            [G3, N, N, N ] + [ B1, N, N, N ] * 3,
            [R2, N, N, N ] + [ B1, N, N, N ] * 3,
            [R3, N, N, N ] + [ B1, N, N, N ] * 3,
            [R4, N, N, N ] + [ B1, N, N, N ] * 3,
            [G4, N, N, N ] + [ B1, N, N, N ] * 3,
            [R2, N, N, N ] + [ B1, N, N, N ] * 3,
            [R3, N, N, N ] + [ B1, N, N, N ] * 3,
            [R4, N, N, N ] + [ B1, N, N, N ] * 3,
        ],
        [
            N,
            N,
            N,
            N,
            ROW1,
            N,
            N,
            N,
            ROW1,
            N,
            N,
            N,
            ROW1,
            N,
            N,
            N,
        ]
    )
)
```

この３つ目の次元を**第三次元**と呼びます。

### サブディヴィジョンとは

サブディヴィジョンとは、声出しカウントを行う時に数字の間にいれるアルファベットと記号のことです。

```{python}
#| output: asis
print(
    show_beat(
        split2d( """
            1 e & a 2 e & a 3 e & a 4 e & a
        """),
        split2d("""
            N0 b1 b1 b1 N0 b1 b1 b1 N0 b1 b1 b1 N0 b1 b1 b1
        """)
    )
)
```

サブディヴィジョンをカウントする時は数字ではなく、記号（＆）とアルファベットを使います。ここで使われる記号アルファベットは次の通りです。

* a ( アー )
* & ( アンド )
* e (イー)

ここではこのサブディヴィジョンを多次元化します。

#### サブディヴィジョンの多次元化する

サブディヴィジョンの多次元化は、これまで数字に対して行っていた多次元化を、記号アルファベットに対して行うことを言います。

次のようにサブディヴィジョンがあったとします。

```{python}
#| output: asis
print(
    show_beat(
        split2d( """
            1 e & a 
        """),
        split2d("""
            B1 n0 n0 n0 B1 n0 n0 n0 B1 n0 n0 n0 B1 n0 n0 n0 
        """)
    )
)
```

この通常のサブディヴィジョンはいわば一次元のサブディヴィジョンということができます。

#### 一次元サブディヴィジョンの多次元化

この 1 e & a を 4回繰り返して読み、更に先頭の記号アルファベットを 1 e & a の順番で入れ替えることにより、あたかも一次元に並んでいる記号アルファベットを、二次元化した上で再度一次元に投影展開するのと同じ処理を行うことが出来ます。

```{python}
#| output: asis
print(
    show_beat(
        split2d( """
            1 e & a
            e e & a
            & e & a
            a e & a
        """),
        split2d("""
            B1 n0 n0 n0
            B1 n0 n0 n0
            B1 n0 n0 n0
            B1 n0 n0 n0
        """)
    )
)
```

横に並べると次の様になります。

```{python}
#| output: asis
print(
    show_beat(
        split2d( """
            1 e & a e e & a & e & a a e & a
        """),
        split2d("""
            B1 n0 n0 n0 B1 n0 n0 n0 B1 n0 n0 n0 B1 n0 n0 n0
        """)
    )
)
```

この様にサブディヴィジョンの記号アルファベットを多次元化することを**サブディヴィジョンの多次元化** と呼びます。

#### 多次元化したサブディヴィジョンをもう一度多次元化する

既に多次元化したサブディヴィジョンを更に多次元化することも可能です。 次の様に更にもう一次元増やすことで**三次元マクロディヴィジョン(Triple-Layered Macrodivision)** を構築できます。

```{python}
#| output: asis
print(
    show_beat(
        split2d( """
            1 e & a e e & a & e & a a e & a
            e e & a e e & a & e & a a e & a
            & e & a e e & a & e & a a e & a
            a e & a e e & a & e & a a e & a
        """),
        split2d("""
            B1 n0 n0 n0 B1 n0 n0 n0 B1 n0 n0 n0 B1 n0 n0 n0
            B2 n0 n0 n0 B1 n0 n0 n0 B1 n0 n0 n0 B1 n0 n0 n0
            B3 n0 n0 n0 B1 n0 n0 n0 B1 n0 n0 n0 B1 n0 n0 n0
            B4 n0 n0 n0 B1 n0 n0 n0 B1 n0 n0 n0 B1 n0 n0 n0
        """)
    )
)
```

この表を立体的に並べてみると次の様になります。

<div class="perspwrap" style="z-index:40"><div class="perspinner">
```{python}
#| output: asis
print(
    show_beat(
        split2d( """
            1 e & a
            e e & a
            & e & a
            a e & a
        """),
        split2d("""
            B1 n0 n0 n0 B1 n0 n0 n0 B1 n0 n0 n0 B1 n0 n0 n0
        """),
        [],
        "persptable divisions"
      )
    )
```
</div></div>

<div class="perspwrap" style="z-index:30"><div class="perspinner">
```{python}
#| output: asis
print(
    show_beat(
        split2d( """
            e e & a
            e e & a
            & e & a
            a e & a
        """),
        split2d("""
            B2 n0 n0 n0 B1 n0 n0 n0 B1 n0 n0 n0 B1 n0 n0 n0
        """),
        [],
        "persptable divisions"
      )
)
```
</div></div>

<div class="perspwrap" style="z-index:20"><div class="perspinner">
```{python}
#| output: asis
print(
    show_beat(
        split2d( """
            & e & a
            e e & a
            & e & a
            a e & a
        """),
        split2d("""
            B3 n0 n0 n0 B1 n0 n0 n0 B1 n0 n0 n0 B1 n0 n0 n0
        """),
        [],
        "persptable divisions"
    )
)
```
</div></div>

<div class="perspwrap" style="z-index:10"><div class="perspinner">
```{python}
#| output: asis
print(
    show_beat(
        split2d( """
            a e & a
            e e & a
            & e & a
            a e & a
        """),
        split2d("""
            B4 n0 n0 n0 B1 n0 n0 n0 B1 n0 n0 n0 B1 n0 n0 n0
        """),
        [],
        "persptable divisions"
    )
)
```
</div></div>

### 多次元化したサブディヴィジョンの呼び方

#### 一次元サブディヴィジョン＝第一次元

次の様に数えることを**一次元サブディヴィジョン(One-Dimensional Subdivision)**と呼びます。
```{python}
#| output: asis
print(
    show_beat(
        split2d( """
            1 e & a 
        """),
        split2d("""
            B1 n0 n0 n0 B1 n0 n0 n0 B1 n0 n0 n0 B1 n0 n0 n0 
        """)
    )
)
```

#### 二次元サブディヴィジョン＝第二次元

次の様に数えることを**二次元サブディヴィジョン(Two-Dimensional Subdivision)**と呼びます。

```{python}
#| output: asis
print(
    show_beat(
        split2d( """
            1 e & a e e & a & e & a a e & a
        """),
        split2d("""
            B1 n0 n0 n0 B1 n0 n0 n0 B1 n0 n0 n0 B1 n0 n0 n0
        """)
    )
)
```

#### 三次元サブディヴィジョン＝第三次元

次の様に数えることを**三次元サブディヴィジョン(Three-Dimensional Subdivision)**と呼びます。


```{python}
#| output: asis
print(
    show_beat(
        split2d( """
            1 e & a e e & a & e & a a e & a
            e e & a e e & a & e & a a e & a
            & e & a e e & a & e & a a e & a
            a e & a e e & a & e & a a e & a
        """),
        split2d("""
            B1 n0 n0 n0 B1 n0 n0 n0 B1 n0 n0 n0 B1 n0 n0 n0
            B2 n0 n0 n0 B1 n0 n0 n0 B1 n0 n0 n0 B1 n0 n0 n0
            B3 n0 n0 n0 B1 n0 n0 n0 B1 n0 n0 n0 B1 n0 n0 n0
            B4 n0 n0 n0 B1 n0 n0 n0 B1 n0 n0 n0 B1 n0 n0 n0
        """)
    )
)
```

### メタディヴィジョンとは

**メタディヴィジョン**とは、サブディヴィジョンよりも細かい音符の音価領域を表す**グルーヴ空間**のひとつです。譜面に書き表すことができない細かなタイミングニュアンスをメタディヴィジョンという仮想のグルーヴ空間として表します。

メタディヴィジョンは、しばしば **ポケット** ・ **レイドバック** ・ **ラッシング** ・**ドラッギング** ・ **プッシュ** 等々と呼ばれるものと同じものです。 メタディヴィジョンは細かすぎる為、意識的に数えることが出来ません。 しかしこのメタディヴィジョンが音楽が持つ全てのニュアンスの鍵を握っていると言って過言でなく、音楽で最も重要な位置にあるリズム要素と言えます。 メタディヴィジョンは、プレーヤー及びリスナー双方の無意識の動きを制御する本質といえます。 メタディヴィジョンの制御の良し悪しひとつで、音楽はこの世のものとは思えない美しさを持って響くこともあれば、どんなに高度な作曲技法を持って作られた曲であろうと無関係に、無惨にも人の心に墨汁を流しこんだような不快感をもたらすこともあります。  ─── メタディヴィジョンは、音楽の全てと言って過言ではありません。

### メタディヴィジョンの定義

メタディヴィジョンは細かすぎる為にはっきりと数えることが出来ません。しかしここで仮説としてメタディヴィジョンを以下の通りに定義します。

* **メタディヴィジョンは、サブディヴィジョンを多次元化する事で定義できる。**
* メタディヴィジョンは、マクロディヴィジョン及び、サブディヴィジョンと同じ性質を持っている。

## グルーヴ空間次元転送について

ディヴィジョンを多次元化したものがサブディヴィジョンであり、かつメタディヴィジョンがサブディヴィジョンを多次元化したものであるならば、それぞれを入れ替えてもリズムは成立する筈です。

* ディヴィジョン → マクロディヴィジョン
* サブディヴィジョン → ディヴィジョン
* メタディヴィジョン→ サブディヴィジョン  （❗❗❗）

つまり

* ゆっくり演奏すると、メタディヴィジョンはサブディヴィジョンになり、サブディヴィジョンはディヴィジョンになり、ディヴィジョンはマクロディヴィジョンに入れ替わるので、メタディヴィジョンも数えることができる。
* マクロディヴィジョン・サブディヴィジョンでの多次元化での様々な複雑なパターンに慣れ親しむことで得られた感覚は、そのままメタディヴィジョンでも応用することが出来る。
* **特にポケットは、メタディヴィジョンでのスコッチスナップである。**
    * → その他の遅れることで生まれるニュアンスは全てここに含まれる。
* **特にプッシュは、メタディヴィジョンでの弱起である。**
    * → その他の早いまることで生まれるニュアンスは全てここに含まれる。

このように全てのグルーヴ空間をひとつずらすことで、認識が難しいメタディヴィジョン・グルーヴ空間を認識しやすくすることをここでは **グルーヴ空間次元転送** と呼びます。

この**グルーヴ空間次元転送**がこの**ハイパーグルーヴ理論の最も重要な理論**と言って過言ではありません。



<!--

#### サブディヴィジョンの多次元化

####多次元化したサブディヴィジョンの多次元化

### マイクロディヴィジョンとは

<blockquote class="twitter-tweet"><p lang="ja" dir="ltr">この曲は3拍子だが、4分音符1つのなかに aid と3つの音素( phoneme )があるので、4分音符を3分割しないと音符を適切に読むことが出来ない。日本語は音符1つに1モーラを割り当てるだけで、モーラには末子音がなく子音が短いので2分割するという感覚を持っていない。ここに根本的感覚の違いがある。 <a href="https://t.co/CcroJRy6yu">https://t.co/CcroJRy6yu</a></p>&mdash; 岡敦/Ats🇯🇵 (@ats4u) <a href="https://twitter.com/ats4u/status/1953003571047489764?ref_src=twsrc%5Etfw">August 6, 2025</a></blockquote>

## オフビートカウントの一般化


## グルーヴ空間とオフビートカウントの組み合わせ

## グルーヴ空間ワープ

次に、一般的にレイドバック・ラッシュ・ドラッグ等々と呼ばれている音符のずれによるニュアンスの表現は、譜面上に表される **サブディヴィジョン(分拍)** よりも更に細かい音符 **マイクロディヴィジョン(微分拍)**空間 が存在すると仮定し、これらに弱拍先行を適用することで合理的に説明できる ─── という理論を御紹介致します。

音符のずれによるニュアンスの表現は、**ディヴィジョン（拍）**  を **マクロディヴィジョン（小節＝合拍）** とみなし **サブディヴィジョン（連符＝分拍）**をディヴィジョンとみなした時のサブディヴィジョンによる弱拍先行リズムとして表現が可能になる ─── **グルーヴ空間ワープ** という理論を御説明致します。

## 拍のレイヤー

これまで「拍 (ディヴィジョン=４分音符）」と、ディヴィジョンを更に分割して出来る「サブディヴィジョン」に対して弱拍先行と多次元を適用するとどうなるかを見てきました。

グルーヴ空間理論とは、拍以外の要素も拍とみなし、再帰的に弱拍先行と多次元を適用できると考える理論です。

グルーヴ空間理論は、まず小節を拍とみなすことが出来るという**マクロディヴィジョン理論**という視点を提示します。そして小節に関しても弱拍先行と多次元を適用することが出来ることを示します。

グルーヴ空間理論は更に、一般的にレイドバック・ラッシュ・ドラッグ等々と表現される音符のずれによるニュアンスの表現について、譜面上に表されるサブディヴィジョンよりも更に細かい音符が存在するという**マクロディヴィジョン理論**を提示します。 この音符のずれはディヴィジョン（拍）を小節としてみなした時の弱拍先行リズムとして表現が可能という仮説を提唱します。

このグルーヴ空間理論については、別章のグルーヴ空間理論とはで更に詳しく見ていきたいと思います。

マイクロディヴィジョンについて説明する文章案
<blockquote class="twitter-tweet"><p lang="ja" dir="ltr">この曲は3拍子だが、4分音符1つのなかに aid と3つの音素( phoneme )があるので、4分音符を3分割しないと音符を適切に読むことが出来ない。日本語は音符1つに1モーラを割り当てるだけで、モーラには末子音がなく子音が短いので2分割するという感覚を持っていない。ここに根本的感覚の違いがある。 <a href="https://t.co/CcroJRy6yu">https://t.co/CcroJRy6yu</a></p>&mdash; 岡敦/Ats🇯🇵 (@ats4u) <a href="https://twitter.com/ats4u/status/1953003571047489764?ref_src=twsrc%5Etfw">August 6, 2025</a></blockquote>

-->

