---
title: メタディヴィジョン理論
created: 2025-05-27T11:07
format: html
execute:
  enabled: true
  echo: false
  output: true
  eval: true
  cache: false
title-block: false
tags:
  - foo
---

リズムを明確かつ精密に認識するための基礎的な技術──それが「メタディヴィジョン理論」です。この理論は、声出しオフビートカウント法を土台として構築されたものであり、グルーヴ解析に特化した汎用的な時間分割の方法論を提供します。

## メタディヴィジョン理論とは

メタディヴィジョン理論とは、拍の数え方を拡張する為の理論です。 これまで  **ディヴィジョン（拍 =４分音符）** と **サブディヴィジョン（分拍＝連符）**  に対して数を数える方法を御説明致しました。このディヴィジョンを**多層化** を使って４つの **グルーヴ空間**に拡張することにより、幅広いグルーヴの理解を行うことができる様にする理論がメタディヴィジョン理論です。

メタディヴィジョンは、ディヴィジョン・サブディヴィジョンを1つの **グルーヴ空間**として扱います。

そしてこのグルーヴ空間を **多層化** を使って拡張し**マクロディヴィジョン(小節)** と **マイクロディヴィジョン(ずれニュアンス)**という２つ**グルーヴ空間**を追加します。

一般的にグルーヴと言われているリズムは、小節自体も拍とみなし小節にも弱拍先行を適用することによって説明出来るという **マクロディヴィジョン・グルーヴ空間** という概念を御紹介致します。

次に、一般的にレイドバック・ラッシュ・ドラッグ等々と呼ばれている音符のずれによるニュアンスの表現は、譜面上に表される **サブディヴィジョン(分拍)** よりも更に細かい音符 **マイクロディヴィジョン(微分拍)**空間 が存在すると仮定し、これらに弱拍先行を適用することで合理的に説明できる ─── という理論を御紹介致します。

音符のずれによるニュアンスの表現は、**ディヴィジョン（拍）**  を **マクロディヴィジョン（小節＝合拍）** とみなし **サブディヴィジョン（連符＝分拍）**をディヴィジョンとみなした時のサブディヴィジョンによる弱拍先行リズムとして表現が可能になる ─── **グルーヴ空間ワープ** という理論を御説明致します。

これらの理論を使うことで、グルーヴ習得の為の具体的な練習方法を考案したり、DAW上で機械的にグルーヴを再現することが出来るようになります。

## ４つのグルーヴ空間
これまでオフビートカウントで拍を数えるにあたって、４分音符１つを１拍とする単位（ディヴィジョン）で数えて来ました。

そして４分音符を分割して出来る８分音符や３連符などの拍（サブ・ディヴィジョン）については、数字ではなく **＆** **Ｅ** **Ａ** の３つの 記号/アルファベット を割り当てることで数えてきました。

このディヴィジョン・サブディヴィジョンのことをここでは**グルーヴ空間** と呼びます。 通常のリズム理論ではこのグルーヴ空間は、**ディヴィジョン** と **サブディヴィジョン** の２つが存在します。

メタディヴィジョン理論では、この２つのグルーヴ空間を**多層化**という処理を加えることにおって拡張し４つのグルーヴ空間を定義します。

* ４つのグルーヴ空間
  * マクロ・ディヴィジョン(小節=合拍=Macrodivision)
  * ディヴィジョン (4分音符=拍=Division )
  * サブ・ディヴィジョン (８分音符等々の分音符=分拍=Subdivision )
  * マイクロ・ディヴィジョン(音符では書き表せない拍＝微分拍=Microdivision)

そしてこの４つのグルーヴ空間の特徴を説明致します。

<style>
  .divisions {
    border : 1px silver solid;
  }
  .divisions td {
    border : 1px silver solid;
    padding: 10px;
  }
  .divisions td.one {
    border-left : 5px silver double;
  }

  .divisions tr.r1 td,
  .divisions tr.r2 td,
  .divisions tr.r3 td,
  .divisions tr.r4 td {
    border-top : 5px silver double;
  }

  .divisions td.l1,
  .divisions td.l2,
  .divisions td.l3,
  .divisions td.l4,

  .divisions td.m1,
  .divisions td.m2,
  .divisions td.m3,
  .divisions td.m4,

  .divisions td.n1,
  .divisions td.n2,
  .divisions td.n3,
  .divisions td.n4
  {
    color : white;
    font-weight: 1000;
    text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000;
  }

  .divisions td.l1 {
    background-color : #DFD;
  }
  .divisions td.l2 {
    background-color : #9F9;
  }
  .divisions td.l3 {
    background-color : #5F5;
  }
  .divisions td.l4 {
    background-color : #1F1;
  }
  .divisions td.m1 {
    background-color : #DDF;
  }
  .divisions td.m2 {
    background-color : #99F;
  }
  .divisions td.m3 {
    background-color : #55F;
  }
  .divisions td.m4 {
    background-color : #11F;
  }
  .divisions td.n1 {
    background-color : #FDD;
  }
  .divisions td.n2 {
    background-color : #FAA;
  }
  .divisions td.n3 {
    background-color : #F66;
  }
  .divisions td.n4 {
    background-color : #F22;
  }
</style>
```{python}
#| output: asis

from html import escape
from typing import Any, Iterable, Sequence

def show_beat(beats: Sequence[Sequence[Any]],
              col_classes : Sequence[Sequence[Any]] | None = None,
              row_classes : Sequence[Any]           | None = None ) -> str:
    """
    Render a 2D HTML table from `beats`, using `col_classes` for per-cell CSS classes.

    - beats[y][x]: cell text (any type; converted to string).
    - col_classes[y][x]: CSS class string (used if truthy and not None).
      If col_classes is None or missing indices, no class attribute is added.

    Returns a complete <table class="divisions">…</table> string.
    """

    col_classes and interpolate2d(col_classes)
    row_classes and interpolate2d(row_classes)

    # Determine max columns across all beat rows (supports ragged input)
    max_cols = max((len(row) for row in beats), default=0)

    html_parts: list[str] = []
    html_parts.append('<table class="divisions">')

    for y, row in enumerate(beats):
        if row_classes is not None and y < len(row_classes):
            crow = row_classes[y]
            html_parts.append( f"<tr class=\"{crow}\">")
        else:
            html_parts.append("<tr>")

        for x in range(max_cols):
            # Cell content
            if x < len(row):
                cell_text = escape(str(row[x]))
            else:
                cell_text = ""  # pad short rows with empty cells

            # Resolve class from col_classes if present/valid
            klass_attr = ""
            if col_classes is not None and y < len(col_classes):
                krow = col_classes[y]
                if x < len(krow):
                    k = krow[x]
                    if k is not None:
                        k_str = str(k).strip()
                        if k_str:
                            klass_attr = f' class="{escape(k_str)}"'

            html_parts.append(f"<td{klass_attr}>{cell_text}</td>")
        html_parts.append("</tr>")

    html_parts.append("</table>")

    return "".join(html_parts)

def interpolate2d(array2d):
    # Replace matching variable names with their values, but skip None
    for i, row in enumerate(array2d):
        if row is None:
            continue
        for j, val in enumerate(row):
            if val is None:
                continue
            if val in globals():           # variable name exists
                value = globals()[val]
                if value is not None:      # skip replacing with None
                    array2d[i][j] = value

def split2d(text):
    return [ line.split() for line in text.strip().split("\n") ]

R1="one r1"
R2="one r2"
R3="one r3"
R4="one r4"

L1="one l1"
L2="one l2"
L3="one l3"
L4="one l4"
M1="one m1"
M2="one m2"
M3="one m3"
M4="one m4"
N1="one n1"
N2="one n2"
N3="one n3"
N4="one n4"

l1="l1"
l2="l2"
l3="l3"
l4="l4"
m1="m1"
m2="m2"
m3="m3"
m4="m4"
n1="n1"
n2="n2"
n3="n3"
n4="n4"

N0="one"
N=None
n=None

```

### ディヴィジョンとは

これまで拍を数えるときは**１２３４、１２３４**と小節を繰り返しながら、その各小節内の拍数を数えて来ました。 この小節を分割して出来る数を **ディヴィジョン** と呼びます。

次の表は、ディヴィジョンの例です。

```{python}
#| output: asis
print(
    show_beat(
        [
            [ 1, 2, 3, 4 ] *4
        ],
        [
            [M1, N, N, N ] *4
        ]
    )
)
```

### 多層化とは

多層化とは、次の様に数を数えるときの**桁数** を増やすことをいいます。前章の例で挙げた様にディヴィジョン（拍数）を数える際、次の様に小節数を同時に数えると次のようになります。

```{python}
#| output: asis
print(
    show_beat(
        [
            [ 1, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ]
        ],
        [
            [N1, N, N, N ] *4
        ]
    )
)
```

この様に拍数を一定の周期で数える時に、その周期の先頭拍で周期が来た回数（小節数）を数えることを **多層化**と呼びます。又は、これまでのオフビートカウントが発展してきた歴史的経緯から **小節数入りカウント**  呼ばれることもあります。

### マクロディヴィジョンとは

マクロディヴィジョンについて説明します。


#### ディヴィジョンを多層化する

ここでディヴィジョン自体を多層化すること考えてみます。次の図は前章で見た図と全く同じディヴィジョンの図です。

```{python}
#| output: asis
print(
    show_beat(
        [
            [ 1, 2, 3, 4 ] *4
        ],
        [
            [M1, N, N, N ] *4
        ]
    )
)
```

このディヴィジョンを多層化すると次の図になります。これも前章で見た図と全く同じ図です。

```{python}
#| output: asis
print(
    show_beat(
        [
            [ 1, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ]
        ],
        [
            [N1, N, N, N ] *4
        ]
    )
)
```

このように多層化されたディヴィジョンのことを **マクロディヴィジョン (Macrodivision)** と呼びます。

#### マクロディヴィジョンを多層化する

このように、小節数入りで数えている時、ある数の小節のまとまりに対して更にもうひとつ階層を増やして数えると次の様になります。

```{python}
#| output: asis
print(
    show_beat(
        [
            [ 1, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 2, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 3, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 4, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
        ],
        [
            [N1, N, N, N ] + [ M1, N, N, N ] * 3,
            [N2, N, N, N ] + [ M1, N, N, N ] * 3,
            [N3, N, N, N ] + [ M1, N, N, N ] * 3,
            [N4, N, N, N ] + [ M1, N, N, N ] * 3,
        ]
    )
)
```

このように数えることを**マクロディヴィジョンの多層化** と呼びます。また多層化されたマクロディヴィジョンを **２階層マクロディヴィジョン(Double-Layered Macrodivision)** と呼びます。

#### 多層化したマクロディヴィジョンを多層化する

既に多層化したマクロディヴィジョンを更に多層化することも可能です。 次の様に更にもう１階層増やすことで**三階層マクロディヴィジョン(Triple-Layered Macrodivision)** を構築できます。

```{python}
#| output: asis
print(
    show_beat(
        [
            [ 1, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 2, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 3, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 4, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 2, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 2, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 3, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 4, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 3, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 2, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 3, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 4, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 4, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 2, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 3, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 4, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
        ],
        [
            [L1, N, N, N ] + [ M1, N, N, N ] * 3,
            [N2, N, N, N ] + [ M1, N, N, N ] * 3,
            [N3, N, N, N ] + [ M1, N, N, N ] * 3,
            [N4, N, N, N ] + [ M1, N, N, N ] * 3,
            [L2, N, N, N ] + [ M1, N, N, N ] * 3,
            [N2, N, N, N ] + [ M1, N, N, N ] * 3,
            [N3, N, N, N ] + [ M1, N, N, N ] * 3,
            [N4, N, N, N ] + [ M1, N, N, N ] * 3,
            [L3, N, N, N ] + [ M1, N, N, N ] * 3,
            [N2, N, N, N ] + [ M1, N, N, N ] * 3,
            [N3, N, N, N ] + [ M1, N, N, N ] * 3,
            [N4, N, N, N ] + [ M1, N, N, N ] * 3,
            [L4, N, N, N ] + [ M1, N, N, N ] * 3,
            [N2, N, N, N ] + [ M1, N, N, N ] * 3,
            [N3, N, N, N ] + [ M1, N, N, N ] * 3,
            [N4, N, N, N ] + [ M1, N, N, N ] * 3,
        ],
        [
            N,
            N,
            N,
            N,
            R1,
            N,
            N,
            N,
            R1,
            N,
            N,
            N,
            R1,
            N,
            N,
            N,
        ]
    )
)
```

#### 多層化したマクロディヴィジョンの呼び方

多層化したマクロディヴィジョンの層の呼び方を説明します。 

##### １階層マクロディヴィジョン＝第１階層
次の様に数えることを**一階層（単層）マクロディヴィジョン(Single-Layered Macrodivision)**と呼びます。

```{python}
#| output: asis
print(
    show_beat(
        [
            [ 1, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 1, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 1, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 1, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
        ],
        [
            [M1, N, N, N ] + [ M1, N, N, N ] * 3,
            [M1, N, N, N ] + [ M1, N, N, N ] * 3,
            [M1, N, N, N ] + [ M1, N, N, N ] * 3,
            [M1, N, N, N ] + [ M1, N, N, N ] * 3,
        ]
    )
)
```
そしてここでは、この階層を **第１階層** と呼びます。

##### ２階層マクロディヴィジョン＝第２階層
次の様に数えることを**二階層マクロディヴィジョン(Double-Layered Macrodivision)** と呼びます。

```{python}
#| output: asis
print(
    show_beat(
        [
            [ 1, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 2, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 3, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 4, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
        ],
        [
            [N1, N, N, N ] + [ M1, N, N, N ] * 3,
            [N2, N, N, N ] + [ M1, N, N, N ] * 3,
            [N3, N, N, N ] + [ M1, N, N, N ] * 3,
            [N4, N, N, N ] + [ M1, N, N, N ] * 3,
        ]
    )
)
```
そしてここでは、この階層を **第2階層** と呼びます。

##### ３階層マクロディヴィジョン＝第３階層
次の様に数えることを**三階層マクロディヴィジョン(Triple-Layered Macrodivision)** と呼びます。

```{python}
#| output: asis
print(
    show_beat(
        [
            [ 1, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 2, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 3, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 4, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 2, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 2, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 3, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 4, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 3, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 2, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 3, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 4, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 4, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 2, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 3, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
            [ 4, 2, 3, 4, 2, 2, 3, 4, 3, 2, 3, 4, 4, 2, 3, 4 ],
        ],
        [
            [L1, N, N, N ] + [ M1, N, N, N ] * 3,
            [N2, N, N, N ] + [ M1, N, N, N ] * 3,
            [N3, N, N, N ] + [ M1, N, N, N ] * 3,
            [N4, N, N, N ] + [ M1, N, N, N ] * 3,
            [L2, N, N, N ] + [ M1, N, N, N ] * 3,
            [N2, N, N, N ] + [ M1, N, N, N ] * 3,
            [N3, N, N, N ] + [ M1, N, N, N ] * 3,
            [N4, N, N, N ] + [ M1, N, N, N ] * 3,
            [L3, N, N, N ] + [ M1, N, N, N ] * 3,
            [N2, N, N, N ] + [ M1, N, N, N ] * 3,
            [N3, N, N, N ] + [ M1, N, N, N ] * 3,
            [N4, N, N, N ] + [ M1, N, N, N ] * 3,
            [L4, N, N, N ] + [ M1, N, N, N ] * 3,
            [N2, N, N, N ] + [ M1, N, N, N ] * 3,
            [N3, N, N, N ] + [ M1, N, N, N ] * 3,
            [N4, N, N, N ] + [ M1, N, N, N ] * 3,
        ],
        [
            N,
            N,
            N,
            N,
            R1,
            N,
            N,
            N,
            R1,
            N,
            N,
            N,
            R1,
            N,
            N,
            N,
        ]
    )
)
```

この３つ目の階層を**第3階層**と呼びます。

### サブディヴィジョンとは

サブディヴィジョンとは、声出しカウントを行う時に数字の間にいれるアルファベットと記号のことです。

```{python}
#| output: asis
print(
    show_beat(
        split2d( """
            1 e & a 2 e & a 3 e & a 4 e & a
        """),
        split2d("""
            N0 m1 m1 m1 N0 m1 m1 m1 N0 m1 m1 m1 N0 m1 m1 m1
        """)
    )
)
```

ここではサブディヴィジョンを多層化します。

(続く)

<!--

#### サブディヴィジョンの多層化

#### 多層化したサブディヴィジョンの多層化

### マイクロディヴィジョンとは

<blockquote class="twitter-tweet"><p lang="ja" dir="ltr">この曲は3拍子だが、4分音符1つのなかに aid と3つの音素( phoneme )があるので、4分音符を3分割しないと音符を適切に読むことが出来ない。日本語は音符1つに1モーラを割り当てるだけで、モーラには末子音がなく子音が短いので2分割するという感覚を持っていない。ここに根本的感覚の違いがある。 <a href="https://t.co/CcroJRy6yu">https://t.co/CcroJRy6yu</a></p>&mdash; 岡敦/Ats🇯🇵 (@ats4u) <a href="https://twitter.com/ats4u/status/1953003571047489764?ref_src=twsrc%5Etfw">August 6, 2025</a></blockquote>

## オフビートカウントの一般化


## メタディヴィジョンとオフビートカウントの組み合わせ

 ## グルーヴ空間ワープ

次に、一般的にレイドバック・ラッシュ・ドラッグ等々と呼ばれている音符のずれによるニュアンスの表現は、譜面上に表される **サブディヴィジョン(分拍)** よりも更に細かい音符 **マイクロディヴィジョン(微分拍)**空間 が存在すると仮定し、これらに弱拍先行を適用することで合理的に説明できる ─── という理論を御紹介致します。

音符のずれによるニュアンスの表現は、**ディヴィジョン（拍）**  を **マクロディヴィジョン（小節＝合拍）** とみなし **サブディヴィジョン（連符＝分拍）**をディヴィジョンとみなした時のサブディヴィジョンによる弱拍先行リズムとして表現が可能になる ─── **グルーヴ空間ワープ** という理論を御説明致します。


## 拍のレイヤー

これまで「拍 (ディヴィジョン=４分音符）」と、ディヴィジョンを更に分割して出来る「サブディヴィジョン」に対して弱拍先行と多層を適用するとどうなるかを見てきました。

メタディヴィジョン理論とは、拍以外の要素も拍とみなし、再帰的に弱拍先行と多層を適用できると考える理論です。

メタディヴィジョン理論は、まず小節を拍とみなすことが出来るという**マクロディヴィジョン理論**という視点を提示します。そして小節に関しても弱拍先行と多層を適用することが出来ることを示します。

メタディヴィジョン理論は更に、一般的にレイドバック・ラッシュ・ドラッグ等々と表現される音符のずれによるニュアンスの表現について、譜面上に表されるサブディヴィジョンよりも更に細かい音符が存在するという**マクロディヴィジョン理論**を提示します。 この音符のずれはディヴィジョン（拍）を小節としてみなした時の弱拍先行リズムとして表現が可能という仮説を提唱します。

このメタディヴィジョン理論については、別章のメタディヴィジョン理論とはで更に詳しく見ていきたいと思います。

マイクロディヴィジョンについて説明する文章案
<blockquote class="twitter-tweet"><p lang="ja" dir="ltr">この曲は3拍子だが、4分音符1つのなかに aid と3つの音素( phoneme )があるので、4分音符を3分割しないと音符を適切に読むことが出来ない。日本語は音符1つに1モーラを割り当てるだけで、モーラには末子音がなく子音が短いので2分割するという感覚を持っていない。ここに根本的感覚の違いがある。 <a href="https://t.co/CcroJRy6yu">https://t.co/CcroJRy6yu</a></p>&mdash; 岡敦/Ats🇯🇵 (@ats4u) <a href="https://twitter.com/ats4u/status/1953003571047489764?ref_src=twsrc%5Etfw">August 6, 2025</a></blockquote>

-->

